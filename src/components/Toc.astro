---
import '../styles/Toc.css';

const props = Astro.props;
const headings = props.headings || [];

function buildGrouped(headings) {
    const acc = [];
    for (const h of headings) {
        if (h.depth === 1) {
            acc.push({ ...h, subheadings: [] });
        } else if (h.depth === 2) {
            if (acc.length === 0) acc.push({ ...h, subheadings: [] });
            else acc[acc.length - 1].subheadings.push({ ...h, subheadings: [] });
        } else if (h.depth === 3) {
            const last = acc[acc.length - 1];
            const lastSub = last && last.subheadings && last.subheadings[last.subheadings.length - 1];
            if (!last) acc.push({ ...h, subheadings: [] });
            else if (!lastSub) last.subheadings.push({ ...h, subheadings: [] });
            else lastSub.subheadings.push({ ...h });
        } else {
            const last = acc[acc.length - 1];
            if (!last) acc.push({ ...h, subheadings: [] });
            else last.subheadings.push({ ...h, subheadings: [] });
        }
    }
    return acc;
}

const groupedHeadings = buildGrouped(headings || []);

if (!groupedHeadings || groupedHeadings.length === 0) {
    // 不渲染 TOC
    return;
}
---
<nav class="toc" aria-label="Table of contents">
    <h1>Table of Contents</h1>
    <ol>
        {groupedHeadings.map((root, i) => (
            <li>
                <a href={`#${root.slug}`}>{i + 1}. {root.text}</a>
                {root.subheadings && root.subheadings.length > 0 && (
                    <ol>
                        {root.subheadings.map((sub, j) => (
                            <li>
                                <a href={`#${sub.slug}`}>{i + 1}.{j + 1}. {sub.text}</a>
                                    {sub.subheadings && sub.subheadings.length > 0 && (
                                        <ol>
                                            {sub.subheadings.map((sub2, k) => (
                                                <li>
                                                    <a href={`#${sub2.slug}`}>{i + 1}.{j + 1}.{k + 1}. {sub2.text}</a>
                                                </li>
                                            ))}
                                        </ol>
                                    )}
                            </li>
                        ))}
                    </ol>
                )}
            </li>
        ))}
    </ol>
</nav>

<script type="module" client:load>
(function () {
    const nav = document.querySelector('.toc');
    if (!nav) return;

    const links = Array.from(nav.querySelectorAll('a[href^="#"]'));
    if (!links.length) return;

    // 建立 mapping（过滤找不到目标的）
    const mapping = links.map(link => {
        const href = link.getAttribute('href');
        if (!href || href.length < 2) return null;
        let id = href.slice(1);
        try { id = decodeURIComponent(id); } catch (e) { /* ignore */ }
        const target = document.getElementById(id);
        if (!target) return null;
        return { link, target };
    }).filter(Boolean);

    if (!mapping.length) return;

    const linkById = new Map(mapping.map(m => [m.target.id, m.link]));

  // 平滑滚动（点击）
    mapping.forEach(({ link, target }) => {
        link.addEventListener('click', function (e) {
            e.preventDefault();
            target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            setTimeout(function () { history.replaceState(null, '', '#' + target.id); }, 120);
        });
    });

    // IntersectionObserver 高亮（简单可靠配置）
    if ('IntersectionObserver' in window) {
        const observer = new IntersectionObserver(function (entries) {
            // 高亮最近的标题
            {
                let closest = null;
                for (const { target } of mapping) {
                    const rect = target.getBoundingClientRect();
                    if (rect.top <= window.innerHeight * 0.5) {
                        const d = Math.abs(rect.top);
                        if (!closest || d < closest.d) closest = { id: target.id, d };
                    }
                }
                if (closest) {
                    linkById.forEach(l => l.classList.remove('active'));
                    const active = linkById.get(closest.id);
                    if (active) active.classList.add('active');
                    return;  // 停止，不让下面 observer 覆盖
                }
            }

            // 在所有 entry 中选取最靠近视口顶部且为可见的元素
            let best = null;
            for (const e of entries) {
                if (!e.isIntersecting) continue;
                if (!best) best = e;
                else if (e.boundingClientRect.top < best.boundingClientRect.top) best = e;
            }

            // 回退：如果没有 isIntersecting 的，选距离顶部最近的（top >= 0）
            if (!best) {
               let closest = null;
               for (const e of entries) {
                  const top = e.boundingClientRect.top;
                        if (top >= 0 && (closest === null || top < closest.top)) closest = { id: e.target.id, top };
               }
           if (closest) best = { target: { id: closest.id } };
           }

            // 更新样式
           linkById.forEach(l => l.classList.remove('active'));
           if (best && best.target && best.target.id) {
               const activeLink = linkById.get(best.target.id);
               if (activeLink) activeLink.classList.add('active');
           }
       }, {
           root: null,
           rootMargin: '0px 0px -70% 0px',
           threshold: 0
       });
        

        mapping.forEach(m => observer.observe(m.target));
    } else {
        // 回退：不支持 IntersectionObserver，使用 scroll 节流检测
        let ticking = false;
        const check = function () {
            let closest = null;
            for (const { target } of mapping) {
                const rect = target.getBoundingClientRect();
                const d = Math.abs(rect.top);
                if (closest === null || d < closest.d) closest = { id: target.id, d };
            }
            if (closest) {
                linkById.forEach(l => l.classList.remove('active'));
                const l = linkById.get(closest.id);
                if (l) l.classList.add('active');
            }
            ticking = false;
        };
        window.addEventListener('scroll', function () {
            if (!ticking) {
                requestAnimationFrame(check);
                ticking = true;
            }
        }, { passive: true });
        // 初次触发一次
        requestAnimationFrame(check);
    }
})();
</script>

